<!-- save as audit.html, then open in mobile Chrome (recommended: serve via http://localhost or https) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mobile Chrome Security Audit (Browser-only)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 16px; }
    h1 { font-size: 18px; margin: 0 0 8px; }
    .muted { color: #555; font-size: 12px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0; }
    button { padding: 10px 12px; border: 1px solid #bbb; background: #fff; border-radius: 10px; cursor: pointer; }
    button:active { transform: translateY(1px); }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 12px; margin: 10px 0; }
    .title { display:flex; align-items:center; justify-content:space-between; gap: 8px; }
    .title strong { font-size: 14px; }
    .pill { font-size: 12px; padding: 2px 8px; border-radius: 999px; border: 1px solid #ccc; }
    .pass { border-color: #0a0; }
    .warn { border-color: #c90; }
    .fail { border-color: #c00; }
    .unknown { border-color: #888; }
    .kv { margin-top: 8px; font-size: 12px; color: #333; line-height: 1.35; }
    .kv div { margin: 4px 0; }
    .k { color:#666; }
    code, pre { background: #f6f6f6; padding: 2px 6px; border-radius: 8px; }
    pre { padding: 10px; overflow:auto; }
    .small { font-size: 12px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 10px; }
    .linkbtn { text-decoration:none; display:inline-block; }
    .danger { color:#b00; }
  </style>
</head>
<body>
  <h1>Mobile Chrome Security Audit (Browser-only)</h1>
  <div class="muted">
    This page only uses Web APIs. It can’t directly read most Chrome settings (Safe Browsing mode, DoH, VPN, proxy, installed CAs).
    It reports what the browser exposes + offers behavior tests you confirm.
  </div>

  <div class="row">
    <button id="runAll">Run all automatic checks</button>
    <button id="exportJson">Export results (JSON)</button>
    <button id="copyJson">Copy JSON</button>
  </div>

  <div class="card">
    <div class="title">
      <strong>Behavior tests (tap, then come back and mark result)</strong>
      <span class="pill warn">MANUAL</span>
    </div>
    <div class="kv small">
      <div class="k">These open a new page. After you see Chrome’s response, return here and click “I saw a warning / No warning”.</div>
      <div class="row" id="manualButtons"></div>
      <div id="manualStatus" class="small"></div>
    </div>
  </div>

  <div id="results" class="grid"></div>

  <div class="card">
    <div class="title">
      <strong>Raw JSON</strong>
      <span class="pill unknown">OUTPUT</span>
    </div>
    <pre id="jsonOut">{}</pre>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const nowIso = () => new Date().toISOString();
  const $ = (id) => document.getElementById(id);

  /** @typedef {"PASS"|"WARN"|"FAIL"|"UNKNOWN"|"MANUAL"} Status */

  /** @type {Array<{id:string, name:string, status:Status, evidence:string, fix:string, how:string, ts:string}>} */
  const checks = [];
  const manual = new Map(); // id -> {status, evidence}

  function setCheck(id, name, status, evidence, how, fix) {
    const ts = nowIso();
    const existingIdx = checks.findIndex(c => c.id === id);
    const rec = { id, name, status, evidence, how, fix, ts };
    if (existingIdx >= 0) checks[existingIdx] = rec;
    else checks.push(rec);
  }

  function pillClass(status) {
    if (status === "PASS") return "pill pass";
    if (status === "WARN") return "pill warn";
    if (status === "FAIL") return "pill fail";
    return "pill unknown";
  }

  function render() {
    // Render cards
    const container = $("results");
    container.innerHTML = "";
    const sorted = [...checks].sort((a,b) => a.id.localeCompare(b.id));
    for (const c of sorted) {
      const div = document.createElement("div");
      div.className = "card";
      div.innerHTML = `
        <div class="title">
          <strong>${escapeHtml(c.id)} — ${escapeHtml(c.name)}</strong>
          <span class="${pillClass(c.status)}">${c.status}</span>
        </div>
        <div class="kv">
          <div><span class="k">Evidence:</span> ${escapeHtml(c.evidence || "")}</div>
          <div><span class="k">How checked:</span> ${escapeHtml(c.how || "")}</div>
          <div><span class="k">Fix hint:</span> ${escapeHtml(c.fix || "")}</div>
          <div><span class="k">Time:</span> ${escapeHtml(c.ts)}</div>
        </div>
      `;
      container.appendChild(div);
    }
    // JSON
    const out = {
      generatedAt: nowIso(),
      url: location.href,
      userAgent: navigator.userAgent,
      checks: sorted
    };
    $("jsonOut").textContent = JSON.stringify(out, null, 2);
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (ch) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[ch]));
  }

  function feature(name, ok, evidence, how, fixIfFail) {
    setCheck(name, name, ok ? "PASS" : "WARN", evidence, how, ok ? "" : (fixIfFail || ""));
  }

  async function safe(fn, fallback) {
    try { return await fn(); } catch (e) { return fallback instanceof Function ? fallback(e) : fallback; }
  }

  // ---------- Automatic checks ----------

  async function checkContext() {
    const protocol = location.protocol;
    const secure = window.isSecureContext === true;
    const ok = secure && (protocol === "https:" || location.hostname === "localhost");
    setCheck(
      "C01",
      "Secure context / HTTPS",
      ok ? "PASS" : "WARN",
      `isSecureContext=${secure}, protocol=${protocol}, host=${location.hostname}`,
      "window.isSecureContext + location.protocol",
      "Serve over https (or use http://localhost for dev)."
    );

    const top = (window.top === window.self);
    setCheck(
      "C02",
      "Top-level browsing context",
      top ? "PASS" : "WARN",
      top ? "Top-level (not in iframe)" : "Running inside an iframe",
      "window.top === window.self",
      "Open the audit page directly (not embedded) for best accuracy."
    );
  }

  async function checkUA() {
    const ua = navigator.userAgent;
    const uad = await safe(async () => {
      if (!navigator.userAgentData) return null;
      const brands = navigator.userAgentData.brands?.map(b => `${b.brand} ${b.version}`).join(", ");
      return { mobile: navigator.userAgentData.mobile, brands };
    }, null);

    setCheck(
      "I01",
      "User agent info",
      "PASS",
      uad ? `UA=${ua}; UAData.mobile=${uad.mobile}; brands=${uad.brands}` : `UA=${ua}; userAgentData not available`,
      "navigator.userAgent (+ navigator.userAgentData if available)",
      ""
    );
  }

  async function checkLanguages() {
    setCheck(
      "I02",
      "Language / locale",
      "PASS",
      `language=${navigator.language}; languages=${(navigator.languages || []).join(", ")}`,
      "navigator.language / navigator.languages",
      ""
    );
  }

  async function checkConnectionHints() {
    const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    if (!c) {
      setCheck("N01", "Network hints", "UNKNOWN", "Network Information API not available", "navigator.connection", "");
      return;
    }
    setCheck(
      "N01",
      "Network hints",
      "PASS",
      `effectiveType=${c.effectiveType}, downlink=${c.downlink}, rtt=${c.rtt}, saveData=${c.saveData}`,
      "navigator.connection",
      ""
    );
  }

  async function checkOnline() {
    setCheck(
      "N02",
      "Online status",
      navigator.onLine ? "PASS" : "WARN",
      `navigator.onLine=${navigator.onLine}`,
      "navigator.onLine",
      "If offline unexpectedly, check Wi-Fi/mobile data, captive portal, or airplane mode."
    );
  }

  async function checkDNT() {
    const dnt = navigator.doNotTrack;
    setCheck(
      "P01",
      "Do Not Track signal (weak)",
      "PASS",
      `navigator.doNotTrack=${String(dnt)}`,
      "navigator.doNotTrack",
      ""
    );
  }

  async function checkCookies() {
    setCheck(
      "S01",
      "Cookies enabled flag",
      navigator.cookieEnabled ? "PASS" : "WARN",
      `navigator.cookieEnabled=${navigator.cookieEnabled}`,
      "navigator.cookieEnabled",
      "If this is false, many sites break. Check Chrome site settings / privacy settings."
    );

    const testName = "audit_cookie_test";
    const val = String(Date.now());
    document.cookie = `${testName}=${val}; Path=/; SameSite=Lax`;
    const ok = document.cookie.includes(`${testName}=${val}`);
    setCheck(
      "S02",
      "1st-party cookie set/read",
      ok ? "PASS" : "WARN",
      ok ? "document.cookie round-trip OK" : "Failed to set/read cookie via document.cookie",
      "document.cookie write + read",
      "If blocked unexpectedly, review site settings / cookie restrictions for this origin."
    );
  }

  async function checkStorage() {
    // localStorage
    const lsOk = await safe(async () => {
      localStorage.setItem("__audit_ls", "1");
      return localStorage.getItem("__audit_ls") === "1";
    }, false);
    setCheck(
      "S03",
      "localStorage",
      lsOk ? "PASS" : "WARN",
      lsOk ? "Readable/writable" : "Blocked/unavailable (exception or mismatch)",
      "localStorage set/get",
      "If blocked, check site settings, incognito restrictions, or storage policies."
    );

    // sessionStorage
    const ssOk = await safe(async () => {
      sessionStorage.setItem("__audit_ss", "1");
      return sessionStorage.getItem("__audit_ss") === "1";
    }, false);
    setCheck(
      "S04",
      "sessionStorage",
      ssOk ? "PASS" : "WARN",
      ssOk ? "Readable/writable" : "Blocked/unavailable",
      "sessionStorage set/get",
      "If blocked, check site settings or browsing mode."
    );

    // indexedDB
    const idbOk = await safe(async () => {
      if (!("indexedDB" in window)) return false;
      return await new Promise((resolve) => {
        const req = indexedDB.open("__audit_idb", 1);
        req.onupgradeneeded = () => { req.result.createObjectStore("s"); };
        req.onsuccess = () => {
          const db = req.result;
          const tx = db.transaction("s", "readwrite");
          tx.objectStore("s").put("1", "k");
          tx.oncomplete = () => { db.close(); resolve(true); };
          tx.onerror = () => { db.close(); resolve(false); };
        };
        req.onerror = () => resolve(false);
      });
    }, false);

    setCheck(
      "S05",
      "IndexedDB",
      idbOk ? "PASS" : "WARN",
      idbOk ? "Open/write OK" : "Unavailable/blocked or write failed",
      "indexedDB open + write",
      "If blocked, review site settings / storage restrictions."
    );

    // Storage persistence (optional)
    const persisted = await safe(async () => {
      if (!navigator.storage?.persisted) return null;
      return await navigator.storage.persisted();
    }, null);

    if (persisted === null) {
      setCheck("S06", "Storage persistence", "UNKNOWN", "StorageManager API not available", "navigator.storage.persisted()", "");
    } else {
      setCheck(
        "S06",
        "Storage persistence",
        persisted ? "PASS" : "WARN",
        `persisted=${persisted}`,
        "navigator.storage.persisted()",
        "If not persisted, storage may be cleared under pressure. Some apps request persistence via navigator.storage.persist()."
      );
    }
  }

  async function checkPermissions() {
    if (!("permissions" in navigator) || !navigator.permissions?.query) {
      setCheck("PR01", "Permissions API availability", "UNKNOWN", "navigator.permissions.query not available", "feature detect", "");
      return;
    }
    setCheck("PR01", "Permissions API availability", "PASS", "Available", "navigator.permissions.query", "");

    const permList = [
      { key: "geolocation", label: "Geolocation" },
      { key: "camera", label: "Camera" },
      { key: "microphone", label: "Microphone" },
      { key: "notifications", label: "Notifications" },
    ];

    for (const p of permList) {
      const res = await safe(async () => {
        const st = await navigator.permissions.query({ name: p.key });
        return st.state; // "granted" | "denied" | "prompt"
      }, "unknown");

      let status = "UNKNOWN";
      if (res === "granted") status = "PASS";
      else if (res === "denied") status = "WARN";
      else if (res === "prompt") status = "WARN";

      setCheck(
        `PR_${p.key.toUpperCase()}`,
        `Permission state: ${p.label}`,
        status,
        `state=${res}`,
        `navigator.permissions.query({name:"${p.key}"})`,
        res === "denied" ? "If you expect it to work, allow it in Chrome site settings for this site." :
        res === "prompt" ? "Will prompt on use. Consider restricting if this site shouldn’t need it." : ""
      );
    }

    // Notification.permission (direct)
    if ("Notification" in window) {
      const np = Notification.permission; // granted/denied/default
      const st = (np === "granted") ? "PASS" : (np === "denied") ? "WARN" : "WARN";
      setCheck(
        "PR_NOTIF_DIRECT",
        "Notification.permission",
        st,
        `Notification.permission=${np}`,
        "Notification.permission",
        np === "default" ? "Default means it may prompt later. Restrict if not needed." :
        np === "denied" ? "Denied means notifications blocked for this origin." : ""
      );
    } else {
      setCheck("PR_NOTIF_DIRECT", "Notification.permission", "UNKNOWN", "Notification API not available", "feature detect", "");
    }
  }

  async function checkIsolation() {
    setCheck(
      "X01",
      "crossOriginIsolated",
      typeof crossOriginIsolated === "boolean"
        ? (crossOriginIsolated ? "PASS" : "WARN")
        : "UNKNOWN",
      `crossOriginIsolated=${String(crossOriginIsolated)}`,
      "global crossOriginIsolated",
      crossOriginIsolated ? "" : "If you need it, serve with COOP/COEP headers (requires server control)."
    );

    const sab = (typeof SharedArrayBuffer !== "undefined");
    setCheck(
      "X02",
      "SharedArrayBuffer availability",
      sab ? "PASS" : "WARN",
      `SharedArrayBuffer=${sab}`,
      "typeof SharedArrayBuffer",
      sab ? "" : "Often requires cross-origin isolation (COOP/COEP)."
    );
  }

  async function checkOpfs() {
    const opfs = !!navigator.storage?.getDirectory;
    setCheck(
      "FS01",
      "OPFS (Origin Private File System)",
      opfs ? "PASS" : "UNKNOWN",
      `navigator.storage.getDirectory=${opfs}`,
      "feature detect navigator.storage.getDirectory",
      ""
    );

    const fsa = typeof window.showOpenFilePicker === "function";
    setCheck(
      "FS02",
      "File System Access API (pickers)",
      fsa ? "PASS" : "UNKNOWN",
      `showOpenFilePicker=${fsa}`,
      "feature detect window.showOpenFilePicker",
      ""
    );
  }

  async function runAllAuto() {
    checks.length = 0;

    await checkContext();
    await checkUA();
    await checkLanguages();
    await checkOnline();
    await checkConnectionHints();
    await checkDNT();
    await checkCookies();
    await checkStorage();
    await checkPermissions();
    await checkIsolation();
    await checkOpfs();

    // Include manual test records (if any)
    for (const [id, rec] of manual.entries()) {
      setCheck(
        id,
        rec.name,
        rec.status,
        rec.evidence,
        rec.how,
        rec.fix
      );
    }

    render();
  }

  // ---------- Manual behavior tests ----------
  const manualTests = [
    {
      id: "M01_CERT_ERROR",
      name: "Cert error interstitial (invalid TLS)",
      how: "Open an invalid/expired/self-signed cert test page and confirm whether Chrome shows a full-page warning.",
      // NOTE: These URLs can change. Replace with your own lab URLs if needed.
      url: "https://expired.badssl.com/",
      fix: "If you did NOT see a warning, something is very wrong (or the test is blocked by network). Check for MITM/VPN/proxy/captive portal."
    },
    {
      id: "M02_MIXED_CONTENT",
      name: "Mixed content blocking (requires HTTPS audit page)",
      how: "This test attempts to load an HTTP resource from this page. Works best if this page is served over https.",
      url: null
    },
    {
      id: "M03_SAFE_BROWSING",
      name: "Safe Browsing interstitial (phishing/malware test)",
      how: "Open a known Safe Browsing test page and confirm whether Chrome shows a warning/interstitial.",
      // Use a Safe Browsing test page you control if possible. This placeholder is intentionally left as a prompt.
      url: "https://testsafebrowsing.appspot.com/",
      fix: "If you did NOT see any warning, Safe Browsing may be off OR the test URL didn’t trigger. Try another test URL."
    }
  ];

  function addManualUI() {
    const wrap = $("manualButtons");
    wrap.innerHTML = "";

    for (const t of manualTests) {
      const openBtn = document.createElement("a");
      openBtn.className = "linkbtn";
      openBtn.target = "_blank";
      openBtn.rel = "noopener";
      openBtn.href = t.url || "#";
      openBtn.innerHTML = `<button>${t.url ? "Open test" : "Run test"}</button>`;

      if (!t.url) {
        openBtn.addEventListener("click", (e) => {
          e.preventDefault();
          runMixedContentTest();
        });
      }

      const sawBtn = document.createElement("button");
      sawBtn.textContent = "I saw a warning ✅";
      sawBtn.addEventListener("click", () => setManual(t, true));

      const noBtn = document.createElement("button");
      noBtn.textContent = "No warning ❌";
      noBtn.addEventListener("click", () => setManual(t, false));

      const label = document.createElement("div");
      label.className = "small";
      label.innerHTML = `<strong>${escapeHtml(t.name)}</strong><br><span class="muted">${escapeHtml(t.how)}</span>`;

      const box = document.createElement("div");
      box.className = "card";
      box.innerHTML = `<div class="title"><strong>${escapeHtml(t.id)}</strong><span class="pill warn">MANUAL</span></div>`;
      const row = document.createElement("div");
      row.className = "row";
      row.appendChild(openBtn);
      row.appendChild(sawBtn);
      row.appendChild(noBtn);
      box.appendChild(label);
      box.appendChild(row);
      wrap.appendChild(box);
    }
  }

  async function runMixedContentTest() {
    // Attempt to load an insecure image. If this page is https, the browser may block it.
    const httpUrl = "http://example.com/"; // intentionally http
    let ok = false;
    let evidence = "";
    // Use an <img> load attempt
    ok = await new Promise((resolve) => {
      const img = new Image();
      let done = false;
      const finish = (val, msg) => {
        if (done) return;
        done = true;
        evidence = msg;
        resolve(val);
      };
      img.onload = () => finish(true, "HTTP subresource loaded (MAY indicate mixed content allowed or page is not HTTPS).");
      img.onerror = () => finish(false, "HTTP subresource blocked/failed to load (expected on HTTPS with mixed content protections).");
      img.src = httpUrl + "favicon.ico?cachebust=" + Date.now();
      setTimeout(() => finish(false, "Timeout loading HTTP subresource (treated as blocked/failed)."), 3500);
    });

    // Record as a manual check entry so it appears in results list
    manual.set("M02_MIXED_CONTENT", {
      name: "Mixed content blocking (HTTP subresource from this page)",
      status: ok ? "WARN" : "PASS",
      evidence: evidence + ` (audit protocol=${location.protocol})`,
      how: "Attempted to load an HTTP image from this page; interpreted success as potentially weaker mixed-content posture.",
      fix: ok ? "If this page is HTTPS and HTTP content still loads, review mixed content policies / network interception. If this page is HTTP, serve via HTTPS to test properly." : ""
    });

    $("manualStatus").innerHTML = `<div class="${ok ? "danger" : ""}">${escapeHtml(evidence)}</div>`;
    render();
  }

  function setManual(t, sawWarning) {
    const status = sawWarning ? "PASS" : "WARN";
    const evidence = sawWarning ? "User confirmed warning/interstitial shown." : "User confirmed NO warning shown.";
    manual.set(t.id, {
      name: t.name,
      status,
      evidence,
      how: t.how,
      fix: sawWarning ? "" : (t.fix || "Retest with a known-good test URL; if still no warning, review Chrome security settings.")
    });
    render();
  }

  // ---------- Export / copy ----------
  function downloadJson() {
    const data = $("jsonOut").textContent;
    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "chrome_audit_results.json";
    a.click();
    URL.revokeObjectURL(url);
  }

  async function copyJson() {
    const data = $("jsonOut").textContent;
    const ok = await safe(async () => {
      await navigator.clipboard.writeText(data);
      return true;
    }, false);

    alert(ok ? "Copied JSON to clipboard." : "Clipboard copy failed. Use the Export button instead.");
  }

  // ---------- Wire up ----------
  $("runAll").addEventListener("click", runAllAuto);
  $("exportJson").addEventListener("click", downloadJson);
  $("copyJson").addEventListener("click", copyJson);

  addManualUI();
  runAllAuto();
})();
</script>
</body>
</html>
